package com.chesapeaketechnology.idl.asm;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import java.util.HashMap;
import java.util.Map;

/**
 * A class visitor that adds helpful methods such as {@link #hashCode()} and {@code copy()}
 * that are not generated by default by the IHMC source code generator.
 *
 * @author Copyright &#169; 2020 Chesapeake Technology International Corp.
 */
public class MethodGenerator extends ClassVisitor implements Opcodes
{
    private final Map<String, String> fields = new HashMap<>();
    private final boolean hash;
    private final boolean copy;
    private boolean isSerializer;
    private Type definingType;

    /**
     * Create the method generator.
     *
     * @param vistor Sub visitor.
     * @param hash   Add hashcode method
     * @param copy   Add copy method.
     */
    public MethodGenerator(ClassVisitor vistor, boolean hash, boolean copy)
    {
        super(ASM8, vistor);
        this.hash = hash;
        this.copy = copy;
    }


    @Override
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces)
    {
        // Get internal name of class
        this.definingType = Type.getObjectType(name);
        // Check if class being visited is IDL representation, or a serializer
        if (interfaces.length == 1 && interfaces[0].equals("us/ihmc/pubsub/TopicDataType"))
            isSerializer = true;
        // Base visit logic
        super.visit(version, access, name, signature, superName, interfaces);
    }

    @Override
    public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value)
    {
        // Record instance fields
        if (isInstance(access))
        {
            fields.put(name, descriptor);
        }
        return super.visitField(access, name, descriptor, signature, value);
    }

    @Override
    public void visitEnd()
    {
        if (!isSerializer)
        {
            if (copy)
            {
                visitCopy();
            }
            if (hash)
            {
                visitHashCode();
            }
        }
        super.visitEnd();
    }

    private void visitCopy()
    {
        MethodVisitor mv = super.visitMethod(ACC_PUBLIC, "copy", "()" + definingType.getDescriptor(), null, null);
        Label lblStart = new Label();
        Label lblEnd = new Label();
        // Start label
        mv.visitLabel(lblStart);
        // Create copy instance
        mv.visitTypeInsn(NEW, definingType.getInternalName());
        mv.visitInsn(DUP);
        mv.visitMethodInsn(INVOKESPECIAL, definingType.getInternalName(), "<init>", "()V", false);
        // Duplicate, one reference to call "set", another for the return value
        mv.visitInsn(DUP);
        // copy.set(this)
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKEVIRTUAL, definingType.getInternalName(), "set", "(" + definingType.getDescriptor() + ")V", false);
        // Return the remaining instance on the stack
        mv.visitInsn(ARETURN);
        // End label
        mv.visitLabel(lblEnd);
        // Visit max stack/local sizes
        mv.visitMaxs(3, 1);
        // Add "this" local
        mv.visitLocalVariable("this", definingType.getDescriptor(), null, lblStart, lblEnd, 0);
        // Done
        mv.visitEnd();
    }

    private void visitHashCode()
    {
        MethodVisitor mv = super.visitMethod(ACC_PUBLIC, "hashCode", "()I", null, null);
        Label lblStart = new Label();
        Label lblEnd = new Label();
        // Start label
        mv.visitLabel(lblStart);
        // Create array
        int[] index = {0};
        visitInt(mv, fields.size());
        mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
        // Insert each field reference into the array
        fields.forEach((name, desc) -> {
            // Keep array reference
            mv.visitInsn(DUP);
            // Index to store value
            visitInt(mv, index[0]++);
            // Load "this"
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, definingType.getInternalName(), name, desc);
            visitConvertToObject(mv, desc);
            mv.visitInsn(AASTORE);
        });
        mv.visitMethodInsn(INVOKESTATIC, "java/util/Objects", "hash", "([Ljava/lang/Object;)I", false);
        mv.visitInsn(IRETURN);
        // End label
        mv.visitLabel(lblEnd);
        // Visit max stack/local sizes
        mv.visitMaxs(fields.size() + 1, 1);
        // Add "this" local
        mv.visitLocalVariable("this", definingType.getDescriptor(), null, lblStart, lblEnd, 0);
        // Done
        mv.visitEnd();
    }

    /**
     * Visit method, converting the type on the top of the stack to an object if necessary.
     *
     * @param mv   Method visitor.
     * @param desc Descriptor of type on stack.
     */
    private static void visitConvertToObject(MethodVisitor mv, String desc)
    {
        // Convert StringBuilder to String
        if (desc.equals("Ljava/lang/StringBuilder;"))
        {
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false);
        }
        // Primitives are only one char long, skip other non-primitives
        else if (desc.length() > 1)
        {
            return;
        }
        // Use "<PrimBoxType>.valueOf(<Prim>)"
        switch (desc)
        {
            case "Z":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
                break;
            case "C":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false);
                break;
            case "B":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false);
                break;
            case "S":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false);
                break;
            case "I":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false);
                break;
            case "F":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false);
                break;
            case "J":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false);
                break;
            case "D":
                mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false);
                break;
        }
    }

    /**
     * Visit method with a specified number.
     *
     * @param mv   Method visitor.
     * @param size Integer to add to the instructions.
     */
    private static void visitInt(MethodVisitor mv, int size)
    {
        if (size <= 5)
        {
            switch (size)
            {
                case 0:
                    mv.visitInsn(ICONST_0);
                    break;
                case 1:
                    mv.visitInsn(ICONST_1);
                    break;
                case 2:
                    mv.visitInsn(ICONST_2);
                    break;
                case 3:
                    mv.visitInsn(ICONST_3);
                    break;
                case 4:
                    mv.visitInsn(ICONST_4);
                    break;
                case 5:
                    mv.visitInsn(ICONST_5);
                    break;
                default:
                    throw new IllegalStateException("Did not visit with value: " + size);
            }
        } else if (size <= 127)
        {
            mv.visitIntInsn(BIPUSH, size);
        } else if (size <= 32767)
        {
            mv.visitIntInsn(SIPUSH, size);
        } else
        {
            mv.visitLdcInsn(size);
        }
    }

    /**
     * @param access Field access modifiers.
     * @return {@code true} when the modifiers do not inclue static.
     */
    private static boolean isInstance(int access)
    {
        return !isStatic(access);
    }

    /**
     * @param access Field access modifiers.
     * @return {@code true} when the modifiers include static.
     */
    private static boolean isStatic(int access)
    {
        return (access & ACC_STATIC) == ACC_STATIC;
    }
}
