package com.chesapeaketechnology.idl.asm;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.Modifier;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.AssignExpr;
import com.github.javaparser.ast.expr.FieldAccessExpr;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.NameExpr;
import com.github.javaparser.ast.expr.VariableDeclarationExpr;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.ReturnStmt;
import com.github.javaparser.ast.type.Type;

import java.util.List;
import java.util.Objects;
import java.util.function.BiPredicate;
import java.util.stream.Collectors;

/**
 * A class visitor that adds helpful methods such as {@link #hashCode()} and {@code copy()}
 * that are not generated by default by the IHMC source code generator.
 *
 * @author Copyright &#169; 2020 Chesapeake Technology International Corp.
 */
public class MethodGenerator
{
    private final boolean hash;
    private final boolean copy;
    private final boolean constructor;
    private final String code;
    private boolean isIdlType;

    /**
     * Create the method generator.
     *
     * @param code        Initial source code.
     * @param hash        Add hashcode method
     * @param copy        Add copy method.
     * @param constructor Add field-setting constructor.
     */
    public MethodGenerator(String code, boolean hash, boolean copy, boolean constructor)
    {
        this.code = code;
        this.hash = hash;
        this.copy = copy;
        this.constructor = constructor;
        this.isIdlType = code.contains("extends Packet<");
    }

    /**
     * @return Modified source.
     */
    public String apply()
    {
        // Do not update non-idl types (idl-specified enums get skipped with this)
        if (!isIdlType)
        {
            return code;
        }
        // Check if no changes were specified
        if (!hash && !copy && !constructor)
        {
            return code;
        }
        ParseResult<CompilationUnit> result = new JavaParser().parse(code);
        CompilationUnit cu = result.getResult().get();
        if (constructor)
        {
            visitConstructor(cu);
        }
        if (copy)
        {
            visitCopy(cu);
        }
        if (hash)
        {
            visitHashcode(cu);
        }
        return cu.toString();
    }

    /**
     * <pre>return Objects.hash(one, two...)</pre>
     *
     * @param cu Unit to modify.
     */
    private void visitHashcode(CompilationUnit cu)
    {
        BlockStmt block = new BlockStmt();
        MethodCallExpr call = new MethodCallExpr(new NameExpr("Objects"), "hash");
        for (FieldDeclaration field : cu.findAll(FieldDeclaration.class))
        {
            if (field.getCommonType().asString().endsWith("StringBuilder"))
            {
                call.addArgument(new NameExpr(field.getVariable(0).getName() + ".toString()"));
            } else
            {
                call.addArgument(new NameExpr(field.getVariable(0).getName()));
            }
        }
        block.addStatement(new ReturnStmt(call));
        //
        MethodDeclaration method = new MethodDeclaration();
        method.addAnnotation(Override.class);
        method.setName("hashCode");
        method.setModifiers(Modifier.Keyword.PUBLIC);
        method.setType(int.class);
        method.setBody(block);
        // Add import and method definition
        cu.getImports().add(new ImportDeclaration(Objects.class.getName(), false, false));
        cu.getClassByName(getPrimaryType(cu)).get().addMember(method);
    }

    /**
     * <pre>
     * Type t = new Type()
     * t.set(this)
     * return t
     * </pre>
     *
     * @param cu Unit to modify.
     */
    private void visitCopy(CompilationUnit cu)
    {
        Type selfType = StaticJavaParser.parseType(getPrimaryType(cu));
        BlockStmt block = new BlockStmt();
        VariableDeclarationExpr v = new VariableDeclarationExpr();
        v.addVariable(new VariableDeclarator(selfType, "copy"));
        v.getVariable(0).setInitializer("new " + selfType + "()");
        MethodCallExpr call = new MethodCallExpr(v.getVariable(0).getNameAsExpression(), "set", new NodeList<>(new NameExpr("this")));
        block.addStatement(v);
        block.addStatement(call);
        block.addStatement(new ReturnStmt(v.getVariable(0).getNameAsExpression()));
        //
        MethodDeclaration method = new MethodDeclaration();
        method.setName("copy");
        method.setModifiers(Modifier.Keyword.PUBLIC);
        method.setType(selfType);
        method.setBody(block);
        // Add right after the "set" method
        insertAfter(cu, method,
                (before, next) -> before instanceof MethodDeclaration && ((MethodDeclaration) before).getNameAsString().equals("set"));
    }

    /**
     * <pre>
     * Type(t one, t two) {
     * this.one = one;
     * this.two = two
     * }
     * </pre>
     *
     * @param cu Unit to modify.
     */
    private void visitConstructor(CompilationUnit cu)
    {
        // Generate constructor parameters
        List<Parameter> params = cu.findAll(FieldDeclaration.class).stream()
                .map(field -> new Parameter(field.getCommonType(), field.getVariable(0).getNameAsString()))
                .map(param -> {
                    // Change StringBuilder to String for constructor parameters
                    if (param.getType().asString().endsWith("StringBuilder"))
                    {
                        param.setType("String");
                    }
                    return param;
                }).collect(Collectors.toList());
        ConstructorDeclaration constructor = new ConstructorDeclaration(getPrimaryType(cu));
        constructor.setParameters(new NodeList<>(params));
        constructor.setPublic(true);
        BlockStmt block = new BlockStmt();
        for (FieldDeclaration field : cu.findAll(FieldDeclaration.class))
        {
            if (field.getCommonType().asString().endsWith("StringBuilder")) {
                String name = field.getVariable(0).getNameAsString();
                AssignExpr assign = new AssignExpr(new FieldAccessExpr(
                        new NameExpr("this"), name), new NameExpr("new StringBuilder(" + name + ")"), AssignExpr.Operator.ASSIGN);
                block.addStatement(assign);
            }
            else
            {
                String name = field.getVariable(0).getNameAsString();
                AssignExpr assign = new AssignExpr(new FieldAccessExpr(new NameExpr("this"), name), new NameExpr(name), AssignExpr.Operator.ASSIGN);
                block.addStatement(assign);
            }
        }
        constructor.setBody(block);
        // Add after other constructors
        insertAfter(cu, constructor,
                (before, next) -> before instanceof ConstructorDeclaration && next instanceof MethodDeclaration);
    }

    private String getPrimaryType(CompilationUnit cu)
    {
        return cu.findAll(TypeDeclaration.class).get(0).getNameAsString();
    }

    private void insertAfter(CompilationUnit cu, BodyDeclaration<?> body, BiPredicate<Node, Node> predicate) {
        ClassOrInterfaceDeclaration dec = cu.getClassByName(getPrimaryType(cu)).get();
        for (int i = 0; i < dec.getMembers().size(); i++) {
            Node before = i == 0 ? null : dec.getMember(i - 1);
            Node next = dec.getMember(i);
            if (predicate.test(before, next)) {
                dec.getMembers().add(i, body);
                return;
            }
        }
    }
}
